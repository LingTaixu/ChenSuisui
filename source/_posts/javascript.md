---
layout: old
title: 面试题
date: 2023-03-08 15:28:02
tags: 旧
---

# JavaScript


## js中的作用域与变量声明提升

- 作用域:每一个`变量`、`函数`都有其作用的`范围`，超出`范围`不得使用，这个叫做作用域
- 全局变量:在全局范围内声明的变量 如 var = 1 只有赋值没有声明的值，如a =1（注：如果a=2在函数环境中，也是全局变量）
- 局部变量:写入`函数`的变量，叫做局部变量，作用范围仅作用于`函数内部`  
- 作用域链：查找变量的过程。先找自己局部环境内部有没有声明或者是函数，如果有，则查看声明有无赋值或者是函数的内容，如果没有，则向`上一级`查找。

#### 变量声明提升：
- 在预编译阶段，编译器会把所有定义的变量全部提升到顶部，既 ，变量声明语句会自动放在`最顶部`


## call apply bind的区别

#### 相同点：
-  三个函数都会改变`this的指向`（调用这三个函数的函数内部的this）

#### 不同点：
- bind会产生`新的函数`，（把对象和函数绑定死后，产生新的函数）
- call和apply`不会产生新的函数`，只是在调用时，绑定一下而已。
- call和apply的区别，第一个参数都是要绑定的this，apply第二个参数是数组（是函数的所有参数），call把apply的第二个参数单列出来。 ---- `传参方式不同`

## let、const、var的区别

#### 区别
- var声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是`全局`的
- 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明；`(变量提升)`
- let是更完美的var，`不是全局变量`，具有块级函数作用域，大多数情况不会发生变量提升。
  - 1. let声明的变量具有块级作用域
  - 2. let生命的变量`不能`通过window.变量名访问
  - 3. 形如for(let x...)的循环是每次迭代都为x创建新的绑定
  - 4. let约束了变量提升
  - 5. let不允许在相同作用域内重复声明同一个变量名，var是允许的
- const定义的常量值，`不能`够重新赋值，如果值是一个对象，可以改变对象里边的属性值。const变量声明的时候必须初始化

#### 箭头函数和普通函数的区别
1. 箭头函数没有`prototype`，所以箭头函数本身没有`this`
2. 箭头函数的this在定义的时候，继承于上一个普通函数的this
3. 如果箭头函数的外层没有一个普通函数，严格模式或者非严格模式下，他的this都会指向window
4. 箭头函数本身的this指向不能改变，但可以修改它要继承的对象的this
5. 箭头函数指向this的全局，使用`arguments`会报未声明错误。
6. 箭头函数的this指向普通函数时,它的`arguments`继承于该普通函数
7. 使用new调用箭头函数会报错，因为箭头函数没有`constructor`
> **`注意`** arguments 是一个对应于传递给函数的参数的类数组对象。


#### 基础数据类型
>  数据类型分为应用类型和基础数据类型
1. 基础数据类型有:String Number Boolean undefined null symbol
2. 引用数据类型有:Object Array Function Date Math
3. 基础数据存放在栈中 引用类型值存放在堆中 地址存放在栈中 通过指针来建立联系

#### JS有哪些内置对象？
**Object Array String Number Boolean**

#### 栈和堆的区别
1. 存放数据类型的不同，栈存放基础数据类型，变量，堆存放应用类型
2. 栈区存放的数据`体积小`，`大小固定`，`使用频繁`，`堆`区存放的数据体积大
3. 数据地址放在栈中，代码解析时先从栈区获取`地址`再从堆区获取`数据`
   
#### 作用域
1. 每一个变量，函数都有其作用的范围，超过这个范围就不得使用，这就叫作用域
2. 作用域它又分为全局作用域，函数作用域和块级作用域。
3. 全局作用域在页面任何位置都能被访问
4. 函数作用域只能在当前函数内部访问，外部无法访问
5. `let` 和 `const` 声明的变量具有块级作用域只在声明的代码块内有效
6. 全局作用域下用var声明的变量是全局变量，只有赋值但没有声明的变量也是全局变量，全局变量可以通过window对象进行访问
7. 在函数内部定义的变量是局部变量，作用范围仅限函数内部，外部无法访问


#### 作用域链
1. 查找变量的过程，如果本作用域有，则查看有无赋值
2. 如果没有找到，则网上一级查找，一直找到全局，如果全局没有则直接报错

#### 类型转换
1. 转数值型  `parseInt()` **整形** , `parseFloat()`浮点型
2. 转字符串  `toString()`  `String()`
3. 数组转字符串 `join()`
4. 字符串转数组 `split()`

#### 面向对象
- 概念
  - 用类，对象，继承，封装等概念进行程序设计
- 优点
  - 代码可读性高，易于维护，易于拓展

#### 面向过程
- 分析解决问题的步骤，要使用的时候就一次一个来调用

#### this指向 
> this在JS中指代函数内部的当前对象
1. 普通函数的this指向`调用它的对象`
2. 构造函数的this指向`实例对象`
3. 箭头函数不绑定this，`但他会捕获其上下文的this，作为自己的this`
4. 对象中方法的this指向`调用它的对象`
5. 事件中的this指向绑定这个事件的`事件源本身`
6. 定时器中的this指向`window`
7. 全局中的this指向`window`

#### 原型和原型
#### 原型
1. 原型: 每一个函数(箭头函数除外)都有一个`prototype`属性
2. `prototype`又会初始化一个空对象，这个对象就是原型对象
3. 原型对象中有一个`constructor`属性会指向构造函数本身
4. 每一个实例化的对象都有一个隐式属性`_proto_`,它又指向原型对象
#### 原型链
1. 每一个实例化的对象都有一个隐式原型`_proto_`，它会指向它的原型对象
2. 而原型对象又有自己的隐式原型`_proto_`，它会指向`Object`的原型对象
3. 直到`Object`原型对象的隐式属性`_proto_`指向null这样的内部就叫做原型链
